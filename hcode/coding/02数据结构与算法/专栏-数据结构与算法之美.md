
## 为何学习

## 如何学习
- 由来/特性/适用场景/能解决的问题

### 书籍
- 大话数据结构
- 算法图解 微信读书
- 
- 数据结构与算法分析：c++语言描述
- 
- 编程之美 微信读书
- 剑指offer 微信读书
- 编程珠玑
- 
- 算法导论 京东实体书 黑书
- 算法 图灵社区PDF
- 
- 计算机程序设计艺术
- 
- 算法帝国
- 数学之美 实体书
- 算法之美

## 复杂度分析

## 数组

## 链表

## 栈

## 队列

## 递归

## 排序

| 算法 | 最好时间复杂度 | 最坏时间复杂度 | 平均时间复杂度 | 空间复杂度 | 是否稳定 | 其他 | 
| --- | --- | --- | --- | --- | --- |  --- |
| 冒泡 | O(n)     | O(n^2)   | O(n^2)   | O(1) | 1 | 原地，交换元素，很少实际应用 |
| 插入 | O(n)     | O(n^2)   | O(n^2)   | O(1) | 1 | 原地，移动元素，应用多，优化：希尔排序 |
| 选择 | O(n^2)   | O(n^2)   | O(n^2)   | O(1) | 0 | 原地，不稳定，很少实际应用 |
| 归并 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 1 | | 
| 快速 | O(nlogn) | O(n^2)   | O(nlogn) | O(1) | 0 | 原地 |
| 堆排 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 0 | 原地 |

### 为何倾向于使用插入排序
- 选择排序不稳定，最好时间复杂度差
- 冒泡排序交换操作的赋值多

### 如何分析一个排序算法
- 执行效率
    - 最好/最坏/平均情况的时间复杂度，以及对应的原始数据类型
    - 时间复杂度的系数/常数和低阶
    - 比较次数或交换/移动次数
- 内存消耗
    - 是否原地排序，即空间复杂度O(1)
- 稳定性
    - 如果待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序不变
    - 电商订单，先按金额排序，金额相同，按下单时间排序。可借助稳定排序算法，先按下单时间排序，再按金额排序
    - 交换会改变元素先后顺序
    - 如果交换导致其他元素间先后顺序变化，则不稳定
    - 非相邻元素发生交换，则不稳定

### 通过交换次数分析平均时间复杂度
- 有序度：数组中具有有序关系的元素对的个数
- 有序元素对：a[i] <= a[j], 如果i < j
- 满有序度：完全有序数组的有序度，为 n(n-1)/2
- 逆有序度：满有序度 - 有序度
- 冒泡排序的交换次数 = 逆有序度 = n(n-1)/2 - 初始有序度
- 冒泡排序的平均交换次数 = n*(n-1)/4，平均时间复杂度为 O(n^2)
- 插入排序的移动次数 = 逆有序度 = n(n-1)/2 - 初始有序度

### 如果前三种排序算法通过链表实现，复杂度如何变化
- 不涉及随机访问，无明显变化

## 二分查找

## 跳表

## 散列表

## 二叉树

### 定义
- 节点：树中元素，如父节点/子节点/兄弟节点/根节点/叶子节点
- 高度：节点到叶子节点的边数
- 深度：根节点到节点的边数
- 层数：深度+1
- 树的高度：根节点的高度
- 二叉树：有一个或左右两个子节点
- 满二叉树：叶子节点全部在最底层，除了叶子节点，每个节点都有左右两个子节点
- 完全二叉树：除了最后一层，其他层的节点个数都要达到最大，最后一层的叶子节点从左到右依次排布

### 存储
- 基于数组的顺序存储或基于指针或引用的二叉链式存储
- 完全二叉树适合用数组存储
- 堆是完全二叉树
- 数组存储，根节点下标为1时，对于下标为i的节点，其左子节点下标为2i，右子节点下标为2i+1，父节点下标为i/2

### 前/中/后序遍历
- 节点与它的左右子树节点遍历打印的先后顺序
- 是一个递归过程
- 时间复杂度为O(n)
- 编码实现

```
preOrder(r) = print r, preOrder(r->left), preOrder(r->right)
inOrder(r) = print inOrder(r->left), r, inOrder(r->right)
postOrder(r) = print postOrder(r->left), postOrder(r->right), r
```

### 卡塔兰数（Catalan）？
- 1,3,5,6,9,10 可以构建多少种不同的二叉树

### 按层遍历

### 二叉查找树
- 同名：二叉搜索树/二叉排序树
- 特点：支持动态数据集合的快速插入/删除/查找操作
- 定义：左子树每个节点的值都小于节点值，右子树每个节点值都大于节点值
- 查找：相等返回，小则查找左子树，大则查找右子树
- 插入：大则插入右子树，小则插入左子树
- 删除：叶子节点，直接删除
- 删除：只有一个子节点，子节点替换
- 删除：有两个子节点，右子树最小节点替换
- 删除：标记删除
- 其他操作：快速查找最大节点/最小节点/前驱节点/后继节点
- 中序遍历可输出有序的数据序列，时间复杂度为O(n)

### 重复数据的二叉查找树
- 通过链表/动态数组等把值相同的数据存储在同一个节点上
- 把等于当作大于处理，查找时到叶子节点才停止

### 二叉查找树的时间复杂度分析
- 最好 O(logn)，完全二叉树
- 最差 O(n)，退化成链表

### 对比散列表
- 散列表无序，二叉查找树有序
- 散列表扩容时消耗很大
- 散列冲突时性能不稳定，实际速度不一定快于O(logn)
- 散列表构造复杂，需考虑散列函数设计/冲突解决办法/扩容/缩容等
- 为了避免散列冲突，装载因子不能太大，浪费空间

### 求一棵树的高度
- 深度优先遍历或按层遍历

### 平衡二叉查找树
- 平衡二叉树：二叉树中任意一个节点的左右子树的高度相差不能大于1
- 平衡二叉查找树：满足二叉查找树定义的平衡二叉树
- 实现：AVL树/红黑树/伸展树（SplayTree）/树堆（Treap）
- 初衷：解决二叉查找树时间复杂度退化的问题

### 红黑树（Red-Black Tree/R-B Tree）定义
- 不严格的平衡二叉查找树
- 根节点是黑色的
- 叶子节点都是黑色的空节点（简化代码实现）
- 相邻节点不能同时为红色
- 从某节点到达其叶子节点的所有路径，包含相同数目的黑色节点

### 红黑树特点
- 近似平衡：高度比较稳定的趋近 logn
- 查找时间复杂度稳定，O(logn)
- 实现复杂度高，自己实现可用跳表替代

### 为何是红黑树
- Treap/SplayTree 无法避免极端情况下时间复杂度的退化
- AVL树 为了维持平衡，插入/删除比较复杂/耗时
- 红黑树各种操作性能稳定，维护平衡的成本低

### 动态数据结构对比
- 动态数据结构指支持动态的插入/删除/查找操作
- 动态数组/链表/队列/栈效率低，不算动态数据结构
- 散列表/跳表/红黑树？

### 红黑树由来：2-3-4树

### 红黑树实现

### 实现
- 实现一个二叉查找树，并且支持插入、删除、查找操作
- 实现查找二叉查找树中某个节点的后继、前驱节点
- 实现二叉树前、中、后序以及按层遍历

## 堆（Heap）

### 定义
- 堆是一个完全二叉树
- 每一个节点的值都必须大(小)于等于其子树中每个节点的值
- 大顶堆/小顶堆

### 存储
- 数组

### 操作
- 插入：从下往上堆化，顺着路径，对比，交换，O(logn)
- 删除堆顶元素：最后元素放至堆顶，从上往下堆化，O(logn)

### 应用场景多
- 堆排序，原地，时间复杂度O(nlogn)，不稳定
- 优先队列
- TopK
- 中位数

### 堆排序
- 建堆和排序
- 建堆方法1：从上往下依次插入（堆化）
- 建堆方法2：从下往上（非叶子节点）依次堆化，时间复杂度是O(n)
- 排序：取堆顶，删除堆顶（重新堆化）
- 不稳定

### 快排为何比堆排序好
- 快排数据顺序访问，，堆排数据跳着访问，堆CPU缓存不友好
- 堆排的数据交换次数要多于快排

### 对于完全二叉树，n/2+1 到 n 的节点都是叶子节点
- 左子节点为2i，n/2+1的左子节点为n+2>n

### 优先级队列
- 算法：赫夫曼编码/图的最短路径/最小生成树
- 合并有序小文件
- 高性能定时器

### TopK
- 维护一个k大小的小顶堆
- 比堆顶元素大则替换堆顶，堆化
- 比堆顶元素小则忽律
- 大顶堆堆顶即所求

### 中位数
- 静态数据直接排序，n/2+1
- 动态数据维护一个大顶堆，一个小顶堆，插入后，调整堆
- 99%响应时间同理，寻找99百分位数据
- 动态数据插入的时间复杂度为O(logn)，查找的为O(1)

### TopK搜索关键词
- 10亿总量，单机1GB内存
- Hash到10个文件
- 对于每个文件，利用散列表，计算关键词搜索次数，利用小顶堆，计算Top10
- 合并10个文件的Top10，重新计算Top10

### 实现
- 实现一个小顶堆、大顶堆、优先级队列
- 实现堆排序
- 利用优先级队列合并 K 个有序数组
- 求一组动态数据集合的最大 TopK

## 图

## 字符串匹配

## 贪心算法

## 回溯算法

## 动态规划

