
## 为何学习

## 如何学习

## 复杂度分析

## 数组

## 链表

## 栈

## 队列

## 递归

## 排序
| 算法 | 最好时间复杂度 | 最坏时间复杂度 | 平均时间复杂度 | 空间复杂度 | 是否稳定 | 其他 | 
| --- | --- | --- | --- | --- | --- |  --- |
| 冒泡 | O(n)     | O(n^2)   | O(n^2)   | O(1) | 1 | 原地，交换元素，很少实际应用 |
| 插入 | O(n)     | O(n^2)   | O(n^2)   | O(1) | 1 | 原地，移动元素，应用多，优化：希尔排序 |
| 选择 | O(n^2)   | O(n^2)   | O(n^2)   | O(1) | 0 | 原地，不稳定，很少实际应用 |
| 归并 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 1 | | 
| 快速 | O(nlogn) | O(n^2)   | O(nlogn) | O(1) | 0 | 原地 |

### 为何倾向于使用插入排序
- 选择排序不稳定，最好时间复杂度差
- 冒泡排序交换操作的赋值多

### 如何分析一个排序算法
- 执行效率
    - 最好/最坏/平均情况的时间复杂度，以及对应的原始数据类型
    - 时间复杂度的系数/常数和低阶
    - 比较次数或交换/移动次数
- 内存消耗
    - 是否原地排序，即空间复杂度O(1)
- 稳定性
    - 如果待排序的序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序不变
    - 电商订单，先按金额排序，金额相同，按下单时间排序。可借助稳定排序算法，先按下单时间排序，再按金额排序
    - 交换会改变元素先后顺序

### 通过交换次数分析平均时间复杂度
- 有序度：数组中具有有序关系的元素对的个数
- 有序元素对：a[i] <= a[j], 如果i < j
- 满有序度：完全有序数组的有序度，为 n(n-1)/2
- 逆有序度：满有序度 - 有序度
- 冒泡排序的交换次数 = 逆有序度 = n(n-1)/2 - 初始有序度
- 冒泡排序的平均交换次数 = n*(n-1)/4，平均时间复杂度为 O(n^2)
- 插入排序的移动次数 = 逆有序度 = n(n-1)/2 - 初始有序度

### 如果前三种排序算法通过链表实现，复杂度如何变化
- 不涉及随机访问，无明显变化

## 二分查找

## 跳表

## 散列表

## 二叉树

## 堆

## 图

## 字符串匹配

## 贪心算法

## 回溯算法

## 动态规划

